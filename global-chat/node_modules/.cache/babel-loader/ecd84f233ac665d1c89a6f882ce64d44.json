{"ast":null,"code":"const Transport = require(\"../transport\");\n\nconst parseqs = require(\"parseqs\");\n\nconst parser = require(\"engine.io-parser\");\n\nconst yeast = require(\"yeast\");\n\nconst debug = require(\"debug\")(\"engine.io-client:polling\");\n\nclass Polling extends Transport {\n  /**\r\n   * Transport name.\r\n   */\n  get name() {\n    return \"polling\";\n  }\n  /**\r\n   * Opens the socket (triggers polling). We write a PING message to determine\r\n   * when the transport is open.\r\n   *\r\n   * @api private\r\n   */\n\n\n  doOpen() {\n    this.poll();\n  }\n  /**\r\n   * Pauses polling.\r\n   *\r\n   * @param {Function} callback upon buffers are flushed and transport is paused\r\n   * @api private\r\n   */\n\n\n  pause(onPause) {\n    this.readyState = \"pausing\";\n\n    const pause = () => {\n      debug(\"paused\");\n      this.readyState = \"paused\";\n      onPause();\n    };\n\n    if (this.polling || !this.writable) {\n      let total = 0;\n\n      if (this.polling) {\n        debug(\"we are currently polling - waiting to pause\");\n        total++;\n        this.once(\"pollComplete\", function () {\n          debug(\"pre-pause polling complete\");\n          --total || pause();\n        });\n      }\n\n      if (!this.writable) {\n        debug(\"we are currently writing - waiting to pause\");\n        total++;\n        this.once(\"drain\", function () {\n          debug(\"pre-pause writing complete\");\n          --total || pause();\n        });\n      }\n    } else {\n      pause();\n    }\n  }\n  /**\r\n   * Starts polling cycle.\r\n   *\r\n   * @api public\r\n   */\n\n\n  poll() {\n    debug(\"polling\");\n    this.polling = true;\n    this.doPoll();\n    this.emit(\"poll\");\n  }\n  /**\r\n   * Overloads onData to detect payloads.\r\n   *\r\n   * @api private\r\n   */\n\n\n  onData(data) {\n    debug(\"polling got data %s\", data);\n\n    const callback = packet => {\n      // if its the first message we consider the transport open\n      if (\"opening\" === this.readyState && packet.type === \"open\") {\n        this.onOpen();\n      } // if its a close packet, we close the ongoing requests\n\n\n      if (\"close\" === packet.type) {\n        this.onClose();\n        return false;\n      } // otherwise bypass onData and handle the message\n\n\n      this.onPacket(packet);\n    }; // decode payload\n\n\n    parser.decodePayload(data, this.socket.binaryType).forEach(callback); // if an event did not trigger closing\n\n    if (\"closed\" !== this.readyState) {\n      // if we got data we're not polling\n      this.polling = false;\n      this.emit(\"pollComplete\");\n\n      if (\"open\" === this.readyState) {\n        this.poll();\n      } else {\n        debug('ignoring poll - transport state \"%s\"', this.readyState);\n      }\n    }\n  }\n  /**\r\n   * For polling, send a close packet.\r\n   *\r\n   * @api private\r\n   */\n\n\n  doClose() {\n    const close = () => {\n      debug(\"writing close packet\");\n      this.write([{\n        type: \"close\"\n      }]);\n    };\n\n    if (\"open\" === this.readyState) {\n      debug(\"transport open - closing\");\n      close();\n    } else {\n      // in case we're trying to close while\n      // handshaking is in progress (GH-164)\n      debug(\"transport not open - deferring close\");\n      this.once(\"open\", close);\n    }\n  }\n  /**\r\n   * Writes a packets payload.\r\n   *\r\n   * @param {Array} data packets\r\n   * @param {Function} drain callback\r\n   * @api private\r\n   */\n\n\n  write(packets) {\n    this.writable = false;\n    parser.encodePayload(packets, data => {\n      this.doWrite(data, () => {\n        this.writable = true;\n        this.emit(\"drain\");\n      });\n    });\n  }\n  /**\r\n   * Generates uri for connection.\r\n   *\r\n   * @api private\r\n   */\n\n\n  uri() {\n    let query = this.query || {};\n    const schema = this.opts.secure ? \"https\" : \"http\";\n    let port = \"\"; // cache busting is forced\n\n    if (false !== this.opts.timestampRequests) {\n      query[this.opts.timestampParam] = yeast();\n    }\n\n    if (!this.supportsBinary && !query.sid) {\n      query.b64 = 1;\n    }\n\n    query = parseqs.encode(query); // avoid port if default for schema\n\n    if (this.opts.port && (\"https\" === schema && Number(this.opts.port) !== 443 || \"http\" === schema && Number(this.opts.port) !== 80)) {\n      port = \":\" + this.opts.port;\n    } // prepend ? to query\n\n\n    if (query.length) {\n      query = \"?\" + query;\n    }\n\n    const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\n    return schema + \"://\" + (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) + port + this.opts.path + query;\n  }\n\n}\n\nmodule.exports = Polling;","map":{"version":3,"sources":["C:/Users/sebas/OneDrive/Desktop/Master Folder/Dev/Web Development/Talkanger/Talkanger/global-chat/node_modules/engine.io-client/lib/transports/polling.js"],"names":["Transport","require","parseqs","parser","yeast","debug","Polling","name","doOpen","poll","pause","onPause","readyState","polling","writable","total","once","doPoll","emit","onData","data","callback","packet","type","onOpen","onClose","onPacket","decodePayload","socket","binaryType","forEach","doClose","close","write","packets","encodePayload","doWrite","uri","query","schema","opts","secure","port","timestampRequests","timestampParam","supportsBinary","sid","b64","encode","Number","length","ipv6","hostname","indexOf","path","module","exports"],"mappings":"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","sourcesContent":["const Transport = require(\"../transport\");\r\nconst parseqs = require(\"parseqs\");\r\nconst parser = require(\"engine.io-parser\");\r\nconst yeast = require(\"yeast\");\r\n\r\nconst debug = require(\"debug\")(\"engine.io-client:polling\");\r\n\r\nclass Polling extends Transport {\r\n  /**\r\n   * Transport name.\r\n   */\r\n  get name() {\r\n    return \"polling\";\r\n  }\r\n\r\n  /**\r\n   * Opens the socket (triggers polling). We write a PING message to determine\r\n   * when the transport is open.\r\n   *\r\n   * @api private\r\n   */\r\n  doOpen() {\r\n    this.poll();\r\n  }\r\n\r\n  /**\r\n   * Pauses polling.\r\n   *\r\n   * @param {Function} callback upon buffers are flushed and transport is paused\r\n   * @api private\r\n   */\r\n  pause(onPause) {\r\n    this.readyState = \"pausing\";\r\n\r\n    const pause = () => {\r\n      debug(\"paused\");\r\n      this.readyState = \"paused\";\r\n      onPause();\r\n    };\r\n\r\n    if (this.polling || !this.writable) {\r\n      let total = 0;\r\n\r\n      if (this.polling) {\r\n        debug(\"we are currently polling - waiting to pause\");\r\n        total++;\r\n        this.once(\"pollComplete\", function() {\r\n          debug(\"pre-pause polling complete\");\r\n          --total || pause();\r\n        });\r\n      }\r\n\r\n      if (!this.writable) {\r\n        debug(\"we are currently writing - waiting to pause\");\r\n        total++;\r\n        this.once(\"drain\", function() {\r\n          debug(\"pre-pause writing complete\");\r\n          --total || pause();\r\n        });\r\n      }\r\n    } else {\r\n      pause();\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Starts polling cycle.\r\n   *\r\n   * @api public\r\n   */\r\n  poll() {\r\n    debug(\"polling\");\r\n    this.polling = true;\r\n    this.doPoll();\r\n    this.emit(\"poll\");\r\n  }\r\n\r\n  /**\r\n   * Overloads onData to detect payloads.\r\n   *\r\n   * @api private\r\n   */\r\n  onData(data) {\r\n    debug(\"polling got data %s\", data);\r\n    const callback = packet => {\r\n      // if its the first message we consider the transport open\r\n      if (\"opening\" === this.readyState && packet.type === \"open\") {\r\n        this.onOpen();\r\n      }\r\n\r\n      // if its a close packet, we close the ongoing requests\r\n      if (\"close\" === packet.type) {\r\n        this.onClose();\r\n        return false;\r\n      }\r\n\r\n      // otherwise bypass onData and handle the message\r\n      this.onPacket(packet);\r\n    };\r\n\r\n    // decode payload\r\n    parser.decodePayload(data, this.socket.binaryType).forEach(callback);\r\n\r\n    // if an event did not trigger closing\r\n    if (\"closed\" !== this.readyState) {\r\n      // if we got data we're not polling\r\n      this.polling = false;\r\n      this.emit(\"pollComplete\");\r\n\r\n      if (\"open\" === this.readyState) {\r\n        this.poll();\r\n      } else {\r\n        debug('ignoring poll - transport state \"%s\"', this.readyState);\r\n      }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * For polling, send a close packet.\r\n   *\r\n   * @api private\r\n   */\r\n  doClose() {\r\n    const close = () => {\r\n      debug(\"writing close packet\");\r\n      this.write([{ type: \"close\" }]);\r\n    };\r\n\r\n    if (\"open\" === this.readyState) {\r\n      debug(\"transport open - closing\");\r\n      close();\r\n    } else {\r\n      // in case we're trying to close while\r\n      // handshaking is in progress (GH-164)\r\n      debug(\"transport not open - deferring close\");\r\n      this.once(\"open\", close);\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Writes a packets payload.\r\n   *\r\n   * @param {Array} data packets\r\n   * @param {Function} drain callback\r\n   * @api private\r\n   */\r\n  write(packets) {\r\n    this.writable = false;\r\n\r\n    parser.encodePayload(packets, data => {\r\n      this.doWrite(data, () => {\r\n        this.writable = true;\r\n        this.emit(\"drain\");\r\n      });\r\n    });\r\n  }\r\n\r\n  /**\r\n   * Generates uri for connection.\r\n   *\r\n   * @api private\r\n   */\r\n  uri() {\r\n    let query = this.query || {};\r\n    const schema = this.opts.secure ? \"https\" : \"http\";\r\n    let port = \"\";\r\n\r\n    // cache busting is forced\r\n    if (false !== this.opts.timestampRequests) {\r\n      query[this.opts.timestampParam] = yeast();\r\n    }\r\n\r\n    if (!this.supportsBinary && !query.sid) {\r\n      query.b64 = 1;\r\n    }\r\n\r\n    query = parseqs.encode(query);\r\n\r\n    // avoid port if default for schema\r\n    if (\r\n      this.opts.port &&\r\n      ((\"https\" === schema && Number(this.opts.port) !== 443) ||\r\n        (\"http\" === schema && Number(this.opts.port) !== 80))\r\n    ) {\r\n      port = \":\" + this.opts.port;\r\n    }\r\n\r\n    // prepend ? to query\r\n    if (query.length) {\r\n      query = \"?\" + query;\r\n    }\r\n\r\n    const ipv6 = this.opts.hostname.indexOf(\":\") !== -1;\r\n    return (\r\n      schema +\r\n      \"://\" +\r\n      (ipv6 ? \"[\" + this.opts.hostname + \"]\" : this.opts.hostname) +\r\n      port +\r\n      this.opts.path +\r\n      query\r\n    );\r\n  }\r\n}\r\n\r\nmodule.exports = Polling;\r\n"]},"metadata":{},"sourceType":"script"}